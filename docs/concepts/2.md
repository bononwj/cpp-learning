# 基本概念

## 4. 智能指针 vs 传统裸指针

智能指针是 C++中的一种指针，它可以帮助我们自动管理内存，避免内存泄漏。

传统裸指针是 C++中的一种指针，它不会自动管理内存，需要我们手动管理内存。

### 智能指针与手动 new+delete 优劣

智能指针 优点：

- 智能指针能够自动管理内存，作用域结束时自动释放资源，极大减少内存泄漏的风险。
- 避免了重复释放、悬空指针等常见的手动管理错误。
- 代码更简洁，易于维护，异常安全性更高。

缺点：

- 智能指针本身有一定的性能开销（如 shared_ptr 的引用计数）。
- 需要理解智能指针的语义（如 unique_ptr 不能复制，只能移动）。
- 不恰当使用（如 shared_ptr 循环引用）仍可能导致内存泄漏。

手动 new/delete 优点：

- 控制更灵活，适合特殊场景下的资源管理。
- 没有智能指针的额外开销。

缺点：

- 容易出现内存泄漏、重复释放、悬空指针等问题。
- 代码复杂，维护成本高，异常安全性差。

举例：

```cpp
int* p = new int(10);
delete p; // 手动释放内存
```

```cpp
std::unique_ptr<int> p(new int(10)); // 自动释放内存
```

## 5. unique_ptr vs shared_ptr

unique_ptr 是独占指针，它只能被一个对象拥有，当对象被销毁时，unique_ptr 会自动释放内存。

shared_ptr 是共享指针，它可以让多个对象拥有同一个指针，当所有对象都销毁时，shared_ptr 会自动释放内存。

```cpp
std::unique_ptr<int> p1(new int(10));
std::unique_ptr<int> p2 = p1; // 错误，unique_ptr 不能被复制
std::unique_ptr<int> p3 = std::move(p1); // 正确，unique_ptr 可以被移动


std::shared_ptr<int> p1(new int(10));
std::shared_ptr<int> p2 = p1;
std::shared_ptr<int> p3 = p2;
std::shared_ptr<int> p4 = p3;
std::shared_ptr<int> p5 = p4;
std::shared_ptr<int> p6 = p5;
std::shared_ptr<int> p7 = p6;
```

## 6. weak_ptr 的作用：为什么需要弱引用？如何避免循环引用？

weak_ptr 是弱引用指针，它不会增加引用计数，当所有对象都销毁时，weak_ptr 会自动释放内存。

```cpp
// 弱引用指针在观察者模式中的应用：
#include <iostream>              // 包含输入输出流头文件
#include <vector>                // 包含vector容器
#include <memory>                // 包含智能指针
#include <mutex>                 // 包含互斥锁

// 前向声明 Observer 类，避免循环依赖
class Observer;

// 被观察者（主题）类
class Subject {
public:
    std::mutex mutex; // 互斥锁，保护 observers 容器的线程安全
    std::vector<std::weak_ptr<Observer>> observers; // 存储观察者的弱引用指针

    // 添加观察者
    void addObserver(const std::shared_ptr<Observer>& observer) {
        std::lock_guard<std::mutex> lock(mutex); // 加锁，保证线程安全
        observers.push_back(observer);           // 添加观察者到容器
    }

    // 通知所有观察者
    void notify() {
        std::lock_guard<std::mutex> lock(mutex); // 加锁，保证线程安全
        for (auto it = observers.begin(); it != observers.end(); ) {
            if (it->expired()) {                 // 如果观察者已失效
                it = observers.erase(it);        // 移除失效的观察者
                continue;
            }
            if (auto obs = it->lock()) {         // 获取有效的 shared_ptr
                obs->update();                   // 调用观察者的 update 方法
            }
            ++it;
        }
    }
};

// 观察者类
class Observer : public std::enable_shared_from_this<Observer> {
public:
    void update() {
        std::cout << "Observer updated" << std::endl; // 输出提示信息
    }
};

void test() {
    Subject subject; // 创建主题对象

    // 创建一个 shared_ptr<Observer>，并注册到主题
    std::shared_ptr<Observer> observer = std::make_shared<Observer>();
    subject.addObserver(observer); // 添加观察者

    subject.notify(); // 通知所有观察者

    observer.reset(); // 手动释放 observer，模拟观察者被销毁

    subject.notify(); // 再次通知，已失效的观察者不会被调用
}
```

## 7. RAII 的优势：相比手动管理内存，RAII 带来了什么好处？

RAII 是 Resource Acquisition Is Initialization 的缩写，它是一种资源管理方式，通过构造函数获取资源，通过析构函数释放资源。

```cpp
class Resource {
  public:
    Resource() {
      std::cout << "Resource acquired" << std::endl;
    }
    ~Resource() {
      std::cout << "Resource released" << std::endl;
    }
  };

  void test() {
    Resource resource;
  }
```

## 常见案例：管理数据库连接的生命周期

```cpp
#include <iostream>
#include <memory>

class DBConnection {
public:
    DBConnection() { std::cout << "DB Connected\n"; }
    ~DBConnection() { std::cout << "DB Disconnected\n"; }
    void query(const std::string& sql) {
        std::cout << "Executing: " << sql << std::endl;
    }
};

void useDatabase() {
    // 使用 unique_ptr 独占管理数据库连接
    std::unique_ptr<DBConnection> conn = std::make_unique<DBConnection>();
    conn->query("SELECT * FROM users");

    // 连接会在作用域结束时自动关闭，无需手动 delete
    // 如果不使用智能指针：
    // 需要手动 new 和 delete，容易忘记释放资源，导致内存泄漏
    DBConnection* rawConn = new DBConnection();
    rawConn->query("SELECT * FROM users");
    delete rawConn; // 必须手动释放
}

int main() {
    useDatabase();
    // 这里 DBConnection 已经被安全释放
    return 0;
}

```
